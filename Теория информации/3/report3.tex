\documentclass[a4paper,14pt]{extarticle}


\usepackage[english,russian]{babel}
\usepackage[T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{ragged2e}
\usepackage[utf8]{inputenc}
\usepackage{hyperref}
\usepackage{minted}
\setmintedinline{frame=lines, framesep=2mm, baselinestretch=1.5, bgcolor=LightGray, breaklines,fontsize=\scriptsize}
\setminted{frame=lines, framesep=2mm, baselinestretch=1.5, bgcolor=LightGray, breaklines,fontsize=\scriptsize}
\usepackage{xcolor}
\definecolor{LightGray}{gray}{0.9}
\usepackage{graphicx}
\usepackage[export]{adjustbox}
\usepackage[left=1cm,right=1cm, top=1cm,bottom=1cm,bindingoffset=0cm]{geometry}
\usepackage{fontspec}
\usepackage{ upgreek }
\usepackage[shortlabels]{enumitem}
\usepackage{adjustbox}
\usepackage{multirow}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{pifont}
\usepackage{pgfplots}
\usepackage{longtable}
\usepackage{array}
\graphicspath{ {./images/} }
\makeatletter
\AddEnumerateCounter{\asbuk}{\russian@alph}{щ}
\makeatother
\setmonofont{Consolas}
\setmainfont{Times New Roman}

\newcommand\textbox[1]{
	\parbox{.45\textwidth}{#1}
} 

\newcommand{\specialcell}[2][c]{%
	\begin{tabular}[#1]{@{}c@{}}#2\end{tabular}}

\begin{document}
\pagenumbering{gobble}
Ранее нами были изучены способы кодировки Шеннона-Фано и Хаффмана, позволяющие составить
оптимальный префиксный код. Однако эти алгоритмы можно улучшить, введя дополнительные 
шаги кодирования. \\
RLE, run-length encoding или кодирование длин серий - алгоритм сжатия данных, заменяющий 
повторяющиеся символы на один символ и число его повторов. Его реализация довольно проста, 
в реализации данной работы для хранения информации о числе повторов выделяется один байт. 
Первый бит этого байта содержит информацию о том, повторяющаяся ли в дальнейшем последовательность
будет перечислена или нет. Следующие 7 бит содержат информацию о количестве символов. Если
последовательность неповторяющаяся, то в 7 битах будет указано количество, сколько следующих байт
нужно будет считать без повторений, если же следует последовательность повторяющаяся, то следующий байт
будет повторяться в исходном файле столько, сколько указано в следующих 7 битах информационного байта.
В первом случае можно сохранить таким образом до 128 включительно байт. 0 байт не может быть, поэтому 
к числу байт нужно прибавить 1, например 0 неповторяющихся байт должны быть интерпретированы как 1 неповторяющийся 
байт. В случае повторяющихся байтов как минимум 2 байта будут повторяться, поэтому к числу нужно прибавить
2, таким образом можно записать до 129 включительно элементов.\\
Для решения проблемы с большим количеством повторений/уникальных символов можно расширить 
размер информационного байта или записать символы в несколько подходов.\\
Были проведены несколько испытаний для различных последовательностей файлов с различными комбинациями кодировок:

\textbf{ads.txt}\\
Текст содержит случайные русские символы, цифры и т.д.\\
\begin{tabular}{cccc}
    Название & Шкала & Коэффициент сжатия & Размер (в байтах)\\
    \hline
    HUF only&\begin{tikzpicture}\filldraw [green] (0, 0) rectangle (0.09184774233317923, 0.3);
    \end{tikzpicture} & 1.896&3129\\
SF only&\begin{tikzpicture}\filldraw [green] (0, 0) rectangle (0.09187709603798369, 0.3);
    \end{tikzpicture} & 1.896&3130\\
Original&\begin{tikzpicture}\filldraw [gray] (0, 0) rectangle (0.17415553060490646, 0.3);
    \end{tikzpicture} & 1.000&5933\\
RLE>SF&\begin{tikzpicture}\filldraw [red] (0, 0) rectangle (0.2019534890547373, 0.3);
    \end{tikzpicture} & 0.862&6880\\
RLE>HUF&\begin{tikzpicture}\filldraw [red] (0, 0) rectangle (0.2019534890547373, 0.3);
    \end{tikzpicture} & 0.862&6880\\
SF>RLE&\begin{tikzpicture}\filldraw [red] (0, 0) rectangle (0.34740109636087446, 0.3);
    \end{tikzpicture} & 0.501&11835\\
HUF>RLE&\begin{tikzpicture}\filldraw [red] (0, 0) rectangle (0.34740109636087446, 0.3);
    \end{tikzpicture} & 0.501&11835\\
RLE only&\begin{tikzpicture}\filldraw [red] (0, 0) rectangle (0.38001306239863797, 0.3);
    \end{tikzpicture} & 0.458&12946\\
RLE2&\begin{tikzpicture}\filldraw [red] (0, 0) rectangle (0.3830071402886937, 0.3);
    \end{tikzpicture} & 0.455&13048\\
SF2&\begin{tikzpicture}\filldraw [red] (0, 0) rectangle (0.3830071402886937, 0.3);
    \end{tikzpicture} & 0.455&13048\\
HUF2&\begin{tikzpicture}\filldraw [red] (0, 0) rectangle (0.3830071402886937, 0.3);
    \end{tikzpicture} & 0.455&13048\\
RLE>SF>RLE&\begin{tikzpicture}\filldraw [red] (0, 0) rectangle (4.0, 0.3);
    \end{tikzpicture} & 0.044&136269\\
RLE>HUF>RLE&\begin{tikzpicture}\filldraw [red] (0, 0) rectangle (4.0, 0.3);
    \end{tikzpicture} & 0.044&136269\\
\end{tabular}\\
В этом случае хорошо себя показали сообщения, закодированные методом Хаффмана и Шеннона-Фано, 
так как в тексте используется не весь алфавит. Кроме того, русские символы, закодированные в UTF-8
состоят из двух байтов, первый байт достаточно часто повторяется, что позволило ещё сильнее сократить
данные в кодировках. Остальные вариации незначительно или сильно увеличили объём информации.\\

\textbf{api-ms-win-core-datetime-l1-1-0.dll}\\
Файл динамической библиотеки\\
\begin{tabular}{cccc}
    Название & Шкала & Коэффициент сжатия & Размер (в байтах)\\
    \hline
    RLE>SF>RLE&\multicolumn{3}{c}{Не прошёл}\\
RLE>HUF>RLE&\multicolumn{3}{c}{Не прошёл}\\
HUF only&\begin{tikzpicture}\filldraw [green] (0, 0) rectangle (0.023179020056242033, 0.3);
    \end{tikzpicture} & 1.085&21711\\
SF only&\begin{tikzpicture}\filldraw [green] (0, 0) rectangle (0.023311404492102842, 0.3);
    \end{tikzpicture} & 1.079&21835\\
Original&\begin{tikzpicture}\filldraw [gray] (0, 0) rectangle (0.025153042813553603, 0.3);
    \end{tikzpicture} & 1.000&23560\\
SF>RLE&\begin{tikzpicture}\filldraw [red] (0, 0) rectangle (0.22487951948720247, 0.3);
    \end{tikzpicture} & 0.112&210637\\
HUF>RLE&\begin{tikzpicture}\filldraw [red] (0, 0) rectangle (0.22487951948720247, 0.3);
    \end{tikzpicture} & 0.112&210637\\
RLE>SF&\begin{tikzpicture}\filldraw [red] (0, 0) rectangle (1.614781576356994, 0.3);
    \end{tikzpicture} & 0.016&1512511\\
RLE>HUF&\begin{tikzpicture}\filldraw [red] (0, 0) rectangle (1.614781576356994, 0.3);
    \end{tikzpicture} & 0.016&1512511\\
RLE only&\begin{tikzpicture}\filldraw [red] (0, 0) rectangle (1.6298232240734691, 0.3);
    \end{tikzpicture} & 0.015&1526600\\
RLE2&\begin{tikzpicture}\filldraw [red] (0, 0) rectangle (4.0, 0.3);
    \end{tikzpicture} & 0.006&3746664\\
SF2&\begin{tikzpicture}\filldraw [red] (0, 0) rectangle (4.0, 0.3);
    \end{tikzpicture} & 0.006&3746664\\
HUF2&\begin{tikzpicture}\filldraw [red] (0, 0) rectangle (4.0, 0.3);
    \end{tikzpicture} & 0.006&3746664\\
\end{tabular}\\
Файл содержит случайные равномерно распределённые байты, поэтому кодирование по Шеннону-Фано и 
Хаффману немного уменьшило конечный результат, но не сильно. Применение RLE так же не имело смысла, так как
повторяющихся байтов в файле мало, и его применение приведёт только к увеличению информации.\\

\textbf{black.dll}\\
Графическое изображение, содержащее только чёрные пиксели\\
\begin{tabular}{cccc}
    Название & Шкала & Коэффициент сжатия & Размер (в байтах)\\
    \hline
    SF>RLE&\begin{tikzpicture}\filldraw [green] (0, 0) rectangle (0.02690687880205896, 0.3);
    \end{tikzpicture} & 148.661&1265\\
HUF>RLE&\begin{tikzpicture}\filldraw [green] (0, 0) rectangle (0.02690687880205896, 0.3);
    \end{tikzpicture} & 148.661&1265\\
RLE>SF&\begin{tikzpicture}\filldraw [green] (0, 0) rectangle (0.036606117326753736, 0.3);
    \end{tikzpicture} & 109.271&1721\\
RLE>HUF&\begin{tikzpicture}\filldraw [green] (0, 0) rectangle (0.036606117326753736, 0.3);
    \end{tikzpicture} & 109.271&1721\\
RLE only&\begin{tikzpicture}\filldraw [green] (0, 0) rectangle (0.08023142042795763, 0.3);
    \end{tikzpicture} & 49.856&3772\\
RLE>SF>RLE&\begin{tikzpicture}\filldraw [green] (0, 0) rectangle (0.10554302973582337, 0.3);
    \end{tikzpicture} & 37.899&4962\\
RLE>HUF>RLE&\begin{tikzpicture}\filldraw [green] (0, 0) rectangle (0.10554302973582337, 0.3);
    \end{tikzpicture} & 37.899&4962\\
RLE2&\begin{tikzpicture}\filldraw [green] (0, 0) rectangle (0.2952737482452036, 0.3);
    \end{tikzpicture} & 13.547&13882\\
SF2&\begin{tikzpicture}\filldraw [green] (0, 0) rectangle (0.2952737482452036, 0.3);
    \end{tikzpicture} & 13.547&13882\\
HUF2&\begin{tikzpicture}\filldraw [green] (0, 0) rectangle (0.2952737482452036, 0.3);
    \end{tikzpicture} & 13.547&13882\\
SF only&\begin{tikzpicture}\filldraw [green] (0, 0) rectangle (0.5067214021355341, 0.3);
    \end{tikzpicture} & 7.894&23823\\
HUF only&\begin{tikzpicture}\filldraw [green] (0, 0) rectangle (0.5067214021355341, 0.3);
    \end{tikzpicture} & 7.894&23823\\
Original&\begin{tikzpicture}\filldraw [gray] (0, 0) rectangle (4.0, 0.3);
    \end{tikzpicture} & 1.000&188056\\
\end{tabular}\\

Здесь алгоритм RLE показывает себя замечательно, в файле содержатся только повторяющиеся пиксели,
RLE может очень легко сократить такие последовательности. Добавив алгоритм Шеннона-Фано или Хаффмана 
сократим повторяющиеся цепочки информационных байтов и байтов идущих после них, кодирование 
RLE>HUF или RLE>SF вырвалось вперёд. Остальные алгоритмы так же справились неплохо.\\

\textbf{img\_random.bmp}\\
Случайное изображение\\
\begin{tabular}{cccc}
    Название & Шкала & Коэффициент сжатия & Размер (в байтах)\\
    \hline
    RLE>SF>RLE  &\multicolumn{3}{c}{Не прошёл}\\
RLE>HUF>RLE&\multicolumn{3}{c}{Не прошёл}\\
HUF only&\begin{tikzpicture}\filldraw [green] (0, 0) rectangle (0.004504656334497011, 0.3);
    \end{tikzpicture} & 1.019&46241\\
SF only&\begin{tikzpicture}\filldraw [green] (0, 0) rectangle (0.00451975595889629, 0.3);
    \end{tikzpicture} & 1.016&46396\\
Original&\begin{tikzpicture}\filldraw [gray] (0, 0) rectangle (0.00459203932214961, 0.3);
    \end{tikzpicture} & 1.000&47138\\
SF>RLE&\begin{tikzpicture}\filldraw [red] (0, 0) rectangle (0.021085018094220878, 0.3);
    \end{tikzpicture} & 0.218&216441\\
HUF>RLE&\begin{tikzpicture}\filldraw [red] (0, 0) rectangle (0.021085018094220878, 0.3);
    \end{tikzpicture} & 0.218&216441\\
RLE>SF&\begin{tikzpicture}\filldraw [red] (0, 0) rectangle (0.7812160867306839, 0.3);
    \end{tikzpicture} & 0.006&8019305\\
RLE>HUF&\begin{tikzpicture}\filldraw [red] (0, 0) rectangle (0.7812160867306839, 0.3);
    \end{tikzpicture} & 0.006&8019305\\
RLE only&\begin{tikzpicture}\filldraw [red] (0, 0) rectangle (0.8075195350172955, 0.3);
    \end{tikzpicture} & 0.006&8289314\\
RLE2&\begin{tikzpicture}\filldraw [red] (0, 0) rectangle (4.0, 0.3);
    \end{tikzpicture} & 0.001&41060624\\
SF2&\begin{tikzpicture}\filldraw [red] (0, 0) rectangle (4.0, 0.3);
    \end{tikzpicture} & 0.001&41060624\\
HUF2&\begin{tikzpicture}\filldraw [red] (0, 0) rectangle (4.0, 0.3);
    \end{tikzpicture} & 0.001&41060624\\

\end{tabular}\\

Алгоритмы Хаффмана и Шеннона-Фано снова выбиваются вперёд. Изображение больше не содержит повторяющихся 
цепочек байтов. Алгоритмы с применением RLE менее эффективны и приводят к увеличению объёма памяти.
Стоит также отметить, что алгоритм Хаффмана оказался эффективней алгоритма Шеннона-Фано.\\

\textbf{img\_random.png}\\
То же изображение, но в нём уже используются алгоритм сжатия LZ77.\\
\begin{tabular}{cccc}
    Название & Шкала & Коэффициент сжатия & Размер (в байтах)\\
    \hline
    HUF only&\begin{tikzpicture}\filldraw [green] (0, 0) rectangle (0.04193643985404834, 0.3);
    \end{tikzpicture} & 1.002&25719\\
Original&\begin{tikzpicture}\filldraw [gray] (0, 0) rectangle (0.042035904173465775, 0.3);
    \end{tikzpicture} & 1.000&25780\\
SF only&\begin{tikzpicture}\filldraw [red] (0, 0) rectangle (0.04207992936402759, 0.3);
    \end{tikzpicture} & 0.999&25807\\
SF>RLE&\begin{tikzpicture}\filldraw [red] (0, 0) rectangle (0.04494971956361253, 0.3);
    \end{tikzpicture} & 0.935&27567\\
HUF>RLE&\begin{tikzpicture}\filldraw [red] (0, 0) rectangle (0.04494971956361253, 0.3);
    \end{tikzpicture} & 0.935&27567\\
RLE>SF&\begin{tikzpicture}\filldraw [red] (0, 0) rectangle (2.471551370263674, 0.3);
    \end{tikzpicture} & 0.017&1515766\\
RLE>HUF&\begin{tikzpicture}\filldraw [red] (0, 0) rectangle (2.471551370263674, 0.3);
    \end{tikzpicture} & 0.017&1515766\\
RLE only&\begin{tikzpicture}\filldraw [red] (0, 0) rectangle (2.4775322739296275, 0.3);
    \end{tikzpicture} & 0.017&1519434\\
RLE>SF>RLE&\begin{tikzpicture}\filldraw [red] (0, 0) rectangle (2.6317166440901687, 0.3);
    \end{tikzpicture} & 0.016&1613993\\
RLE>HUF>RLE&\begin{tikzpicture}\filldraw [red] (0, 0) rectangle (2.6317166440901687, 0.3);
    \end{tikzpicture} & 0.016&1613993\\
RLE2&\begin{tikzpicture}\filldraw [red] (0, 0) rectangle (4.0, 0.3);
    \end{tikzpicture} & 0.011&2453141\\
SF2&\begin{tikzpicture}\filldraw [red] (0, 0) rectangle (4.0, 0.3);
    \end{tikzpicture} & 0.011&2453141\\
HUF2&\begin{tikzpicture}\filldraw [red] (0, 0) rectangle (4.0, 0.3);
    \end{tikzpicture} & 0.011&2453141\\

\end{tabular}\\

Повторное сжатие не дало лучших результатов и привело лишь к увеличению объёма памяти. 
Только алгоритм Хаффмана позволил немного уменьшить изображение.\\

\textbf{laughter\_of\_terror\_ru.txt}\\
Последовательность из нескольких русских символов, пробелов и переносов строки в UTF-8.\\
\begin{tabular}{cccc}
    Название & Шкала & Коэффициент сжатия & Размер (в байтах)\\
    \hline
    HUF only&\begin{tikzpicture}\filldraw [green] (0, 0) rectangle (0.5205930807248764, 0.3);
    \end{tikzpicture} & 2.785&158\\
SF only&\begin{tikzpicture}\filldraw [green] (0, 0) rectangle (0.5436573311367381, 0.3);
    \end{tikzpicture} & 2.667&165\\
SF>RLE&\begin{tikzpicture}\filldraw [green] (0, 0) rectangle (0.5436573311367381, 0.3);
    \end{tikzpicture} & 2.667&165\\
HUF>RLE&\begin{tikzpicture}\filldraw [green] (0, 0) rectangle (0.5436573311367381, 0.3);
    \end{tikzpicture} & 2.667&165\\
Original&\begin{tikzpicture}\filldraw [gray] (0, 0) rectangle (1.4497528830313016, 0.3);
    \end{tikzpicture} & 1.000&440\\
RLE>SF&\begin{tikzpicture}\filldraw [red] (0, 0) rectangle (1.4925864909390445, 0.3);
    \end{tikzpicture} & 0.971&453\\
RLE>HUF&\begin{tikzpicture}\filldraw [red] (0, 0) rectangle (1.4925864909390445, 0.3);
    \end{tikzpicture} & 0.971&453\\
RLE>SF>RLE&\begin{tikzpicture}\filldraw [red] (0, 0) rectangle (1.5749588138385502, 0.3);
    \end{tikzpicture} & 0.921&478\\
RLE>HUF>RLE&\begin{tikzpicture}\filldraw [red] (0, 0) rectangle (1.5749588138385502, 0.3);
    \end{tikzpicture} & 0.921&478\\
RLE only&\begin{tikzpicture}\filldraw [red] (0, 0) rectangle (3.967051070840198, 0.3);
    \end{tikzpicture} & 0.365&1204\\
RLE2&\begin{tikzpicture}\filldraw [red] (0, 0) rectangle (4.0, 0.3);
    \end{tikzpicture} & 0.362&1214\\
SF2&\begin{tikzpicture}\filldraw [red] (0, 0) rectangle (4.0, 0.3);
    \end{tikzpicture} & 0.362&1214\\
HUF2&\begin{tikzpicture}\filldraw [red] (0, 0) rectangle (4.0, 0.3);
    \end{tikzpicture} & 0.362&1214\\

\end{tabular}\\

Последовательность состоит из ограниченного алфавита, повторяющихся цепочек нет. 
Именно поэтому кодирование только при помощи Шеннона-Фано или Хаффмана снова эффективно, 
причём кодирование только Хаффманом оказывается эффективней. Последовательность содержит мало 
повторяющихся цепочек, поэтому применение RLE эффективно только в конце, когда символы уже преобразованы
алгоритмами Хаффмана или Шеннона-Фано.\\

\textbf{lorem\_ipsum.txt}\\
Последовательность из латинских символов.\\
\begin{tabular}{cccc}
    Название & Шкала & Коэффициент сжатия & Размер (в байтах)\\
    \hline
    HUF only&\begin{tikzpicture}\filldraw [green] (0, 0) rectangle (6.326450808448779E-4, 0.3);
    \end{tikzpicture} & 1.862&5798\\
SF only&\begin{tikzpicture}\filldraw [green] (0, 0) rectangle (6.336271101183523E-4, 0.3);
    \end{tikzpicture} & 1.859&5807\\
Original&\begin{tikzpicture}\filldraw [gray] (0, 0) rectangle (0.0011781077850779834, 0.3);
    \end{tikzpicture} & 1.000&10797\\
SF>RLE&\begin{tikzpicture}\filldraw [red] (0, 0) rectangle (0.007074648000472465, 0.3);
    \end{tikzpicture} & 0.167&64837\\
HUF>RLE&\begin{tikzpicture}\filldraw [red] (0, 0) rectangle (0.007074648000472465, 0.3);
    \end{tikzpicture} & 0.167&64837\\
RLE>SF&\begin{tikzpicture}\filldraw [red] (0, 0) rectangle (0.015213924847754775, 0.3);
    \end{tikzpicture} & 0.077&139431\\
RLE>HUF&\begin{tikzpicture}\filldraw [red] (0, 0) rectangle (0.015213924847754775, 0.3);
    \end{tikzpicture} & 0.077&139431\\
RLE only&\begin{tikzpicture}\filldraw [red] (0, 0) rectangle (0.02807185235408102, 0.3);
    \end{tikzpicture} & 0.042&257270\\
RLE2&\begin{tikzpicture}\filldraw [red] (0, 0) rectangle (0.028291172225156945, 0.3);
    \end{tikzpicture} & 0.042&259280\\
SF2&\begin{tikzpicture}\filldraw [red] (0, 0) rectangle (0.028291172225156945, 0.3);
    \end{tikzpicture} & 0.042&259280\\
HUF2&\begin{tikzpicture}\filldraw [red] (0, 0) rectangle (0.028291172225156945, 0.3);
    \end{tikzpicture} & 0.042&259280\\
RLE>SF>RLE&\begin{tikzpicture}\filldraw [red] (0, 0) rectangle (4.0, 0.3);
    \end{tikzpicture} & 0.000&36658785\\
RLE>HUF>RLE&\begin{tikzpicture}\filldraw [red] (0, 0) rectangle (4.0, 0.3);
    \end{tikzpicture} & 0.000&36658785\\

\end{tabular}\\

В обычном тексте символы не будут равномерно распределены, поэтому алгоритмы Шеннона-Фано и Хаффмана
снова вырываются вперёд. Причём Хаффман всё ещё оказывается эффективней. Повторяющиеся байты в обычном тексте
повторяются не так часто, следовательно применение RLE не сильно эффективно. Повторное кодирование и тройного
кодирования всё так же неэффективны и приводят к сильному увеличению размера файла.\\

\textbf{metal\_alphabet\_lyrics.txt}\\
Последовательность из повторяющихся латинских символов, разделённых переводами строки.\\
\begin{tabular}{cccc}
    Название & Шкала & Коэффициент сжатия & Размер (в байтах)\\
    \hline
    RLE>SF&\begin{tikzpicture}\filldraw [green] (0, 0) rectangle (0.3780487804878049, 0.3);
    \end{tikzpicture} & 10.581&62\\
RLE>HUF&\begin{tikzpicture}\filldraw [green] (0, 0) rectangle (0.3780487804878049, 0.3);
    \end{tikzpicture} & 10.581&62\\
RLE>SF>RLE&\begin{tikzpicture}\filldraw [green] (0, 0) rectangle (0.38414634146341464, 0.3);
    \end{tikzpicture} & 10.413&63\\
RLE>HUF>RLE&\begin{tikzpicture}\filldraw [green] (0, 0) rectangle (0.38414634146341464, 0.3);
    \end{tikzpicture} & 10.413&63\\
RLE only&\begin{tikzpicture}\filldraw [green] (0, 0) rectangle (0.774390243902439, 0.3);
    \end{tikzpicture} & 5.165&127\\
RLE2&\begin{tikzpicture}\filldraw [green] (0, 0) rectangle (0.7804878048780488, 0.3);
    \end{tikzpicture} & 5.125&128\\
SF2&\begin{tikzpicture}\filldraw [green] (0, 0) rectangle (0.7804878048780488, 0.3);
    \end{tikzpicture} & 5.125&128\\
HUF2&\begin{tikzpicture}\filldraw [green] (0, 0) rectangle (0.7804878048780488, 0.3);
    \end{tikzpicture} & 5.125&128\\
SF>RLE&\begin{tikzpicture}\filldraw [green] (0, 0) rectangle (2.2865853658536586, 0.3);
    \end{tikzpicture} & 1.749&375\\
HUF>RLE&\begin{tikzpicture}\filldraw [green] (0, 0) rectangle (2.2865853658536586, 0.3);
    \end{tikzpicture} & 1.749&375\\
HUF only&\begin{tikzpicture}\filldraw [green] (0, 0) rectangle (2.4207317073170733, 0.3);
    \end{tikzpicture} & 1.652&397\\
SF only&\begin{tikzpicture}\filldraw [green] (0, 0) rectangle (2.426829268292683, 0.3);
    \end{tikzpicture} & 1.648&398\\
Original&\begin{tikzpicture}\filldraw [gray] (0, 0) rectangle (4.0, 0.3);
    \end{tikzpicture} & 1.000&656\\

\end{tabular}\\

Любой алгоритм в данном случае оказался эффективным. Самым эффективным оказалось применение RLE 
и Хаффмана или Шеннона-Фано. RLE сокращает повторяющиеся байты, а ШФ или Хаф сокращает переводы, 
выраженные двумя байтами. \\
\textbf{metal\_alphabet\_lyrics\_ru.txt}\\
Последовательность из повторяющихся русских символов, разделённых переводами строки.\\
\begin{tabular}{cccc}
    Название & Шкала & Коэффициент сжатия & Размер (в байтах)\\
    \hline
    SF>RLE&\begin{tikzpicture}\filldraw [green] (0, 0) rectangle (0.5035733919736118, 0.3);
    \end{tikzpicture} & 7.817&229\\
HUF>RLE&\begin{tikzpicture}\filldraw [green] (0, 0) rectangle (0.5035733919736118, 0.3);
    \end{tikzpicture} & 7.817&229\\
RLE>SF>RLE&\begin{tikzpicture}\filldraw [green] (0, 0) rectangle (0.7102803738317757, 0.3);
    \end{tikzpicture} & 5.542&323\\
RLE>HUF>RLE&\begin{tikzpicture}\filldraw [green] (0, 0) rectangle (0.7102803738317757, 0.3);
    \end{tikzpicture} & 5.542&323\\
HUF only&\begin{tikzpicture}\filldraw [green] (0, 0) rectangle (1.805387575590984, 0.3);
    \end{tikzpicture} & 2.180&821\\
SF only&\begin{tikzpicture}\filldraw [green] (0, 0) rectangle (1.994502473886751, 0.3);
    \end{tikzpicture} & 1.974&907\\
RLE>SF&\begin{tikzpicture}\filldraw [green] (0, 0) rectangle (2.034084661902144, 0.3);
    \end{tikzpicture} & 1.935&925\\
RLE>HUF&\begin{tikzpicture}\filldraw [green] (0, 0) rectangle (2.034084661902144, 0.3);
    \end{tikzpicture} & 1.935&925\\
Original&\begin{tikzpicture}\filldraw [gray] (0, 0) rectangle (3.936228697086311, 0.3);
    \end{tikzpicture} & 1.000&1790\\
RLE only&\begin{tikzpicture}\filldraw [red] (0, 0) rectangle (3.9670148433205057, 0.3);
    \end{tikzpicture} & 0.992&1804\\
RLE2&\begin{tikzpicture}\filldraw [red] (0, 0) rectangle (4.0, 0.3);
    \end{tikzpicture} & 0.984&1819\\
SF2&\begin{tikzpicture}\filldraw [red] (0, 0) rectangle (4.0, 0.3);
    \end{tikzpicture} & 0.984&1819\\
HUF2&\begin{tikzpicture}\filldraw [red] (0, 0) rectangle (4.0, 0.3);
    \end{tikzpicture} & 0.984&1819\\

\end{tabular}\\

В данном случае буквы будут занимать уже два байта, поэтому эффективней окажется алгоритм, который
сначала применяет алгоритм Хаффмана или Шеннона-Фано, и затем - RLE. Одним из возможных решений
для увеличения эффективности RLE является расширение сегментизации до 2 байтов. \\
\textbf{noise.bmp}\\
Изображение из случайных равнораспределённых байтов\\
\begin{tabular}{cccc}
    Название & Шкала & Коэффициент сжатия & Размер (в байтах)\\
    \hline
    HUF only&\begin{tikzpicture}\filldraw [green] (0, 0) rectangle (0.014057591287545782, 0.3);
    \end{tikzpicture} & 3.281&57313\\
SF only&\begin{tikzpicture}\filldraw [green] (0, 0) rectangle (0.014075741825037772, 0.3);
    \end{tikzpicture} & 3.277&57387\\
RLE>SF&\begin{tikzpicture}\filldraw [green] (0, 0) rectangle (0.021127716195743, 0.3);
    \end{tikzpicture} & 2.183&86138\\
RLE>HUF&\begin{tikzpicture}\filldraw [green] (0, 0) rectangle (0.021127716195743, 0.3);
    \end{tikzpicture} & 2.183&86138\\
RLE only&\begin{tikzpicture}\filldraw [green] (0, 0) rectangle (0.044548286776284876, 0.3);
    \end{tikzpicture} & 1.035&181624\\
Original&\begin{tikzpicture}\filldraw [gray] (0, 0) rectangle (0.0461259118728859, 0.3);
    \end{tikzpicture} & 1.000&188056\\
SF>RLE&\begin{tikzpicture}\filldraw [red] (0, 0) rectangle (1.9208912502574647, 0.3);
    \end{tikzpicture} & 0.024&7831501\\
HUF>RLE&\begin{tikzpicture}\filldraw [red] (0, 0) rectangle (1.9208912502574647, 0.3);
    \end{tikzpicture} & 0.024&7831501\\
RLE2&\begin{tikzpicture}\filldraw [red] (0, 0) rectangle (2.539453228548318, 0.3);
    \end{tikzpicture} & 0.018&10353387\\
SF2&\begin{tikzpicture}\filldraw [red] (0, 0) rectangle (2.539453228548318, 0.3);
    \end{tikzpicture} & 0.018&10353387\\
HUF2&\begin{tikzpicture}\filldraw [red] (0, 0) rectangle (2.539453228548318, 0.3);
    \end{tikzpicture} & 0.018&10353387\\
RLE>SF>RLE&\begin{tikzpicture}\filldraw [red] (0, 0) rectangle (4.0, 0.3);
    \end{tikzpicture} & 0.012&16308057\\
RLE>HUF>RLE&\begin{tikzpicture}\filldraw [red] (0, 0) rectangle (4.0, 0.3);
    \end{tikzpicture} & 0.012&16308057\\

\end{tabular}\\

Результат оказался неожиданным, алгоритм Хаффмана и Шеннона-Фано позволил уменьшить 
размер изображения в 3 раза. Даже применение алгоритмы с применением RLE оказались
эффективными.\\
\textbf{scream\_of\_terror\_en.txt}\\

Последовательность из латинской буквы, пробелов и переносов строки в UTF-8.\\
\begin{tabular}{cccc}
    Название & Шкала & Коэффициент сжатия & Размер (в байтах)\\
    \hline
    RLE>SF&\begin{tikzpicture}\filldraw [green] (0, 0) rectangle (0.28328611898017, 0.3);
    \end{tikzpicture} & 14.120&25\\
RLE>HUF&\begin{tikzpicture}\filldraw [green] (0, 0) rectangle (0.28328611898017, 0.3);
    \end{tikzpicture} & 14.120&25\\
RLE>SF>RLE&\begin{tikzpicture}\filldraw [green] (0, 0) rectangle (0.29461756373937675, 0.3);
    \end{tikzpicture} & 13.577&26\\
RLE>HUF>RLE&\begin{tikzpicture}\filldraw [green] (0, 0) rectangle (0.29461756373937675, 0.3);
    \end{tikzpicture} & 13.577&26\\
SF>RLE&\begin{tikzpicture}\filldraw [green] (0, 0) rectangle (0.44192634560906513, 0.3);
    \end{tikzpicture} & 9.051&39\\
HUF>RLE&\begin{tikzpicture}\filldraw [green] (0, 0) rectangle (0.44192634560906513, 0.3);
    \end{tikzpicture} & 9.051&39\\
SF only&\begin{tikzpicture}\filldraw [green] (0, 0) rectangle (0.6118980169971672, 0.3);
    \end{tikzpicture} & 6.537&54\\
HUF only&\begin{tikzpicture}\filldraw [green] (0, 0) rectangle (0.6118980169971672, 0.3);
    \end{tikzpicture} & 6.537&54\\
RLE only&\begin{tikzpicture}\filldraw [green] (0, 0) rectangle (0.7252124645892352, 0.3);
    \end{tikzpicture} & 5.516&64\\
RLE2&\begin{tikzpicture}\filldraw [green] (0, 0) rectangle (0.7365439093484419, 0.3);
    \end{tikzpicture} & 5.431&65\\
SF2&\begin{tikzpicture}\filldraw [green] (0, 0) rectangle (0.7365439093484419, 0.3);
    \end{tikzpicture} & 5.431&65\\
HUF2&\begin{tikzpicture}\filldraw [green] (0, 0) rectangle (0.7365439093484419, 0.3);
    \end{tikzpicture} & 5.431&65\\
Original&\begin{tikzpicture}\filldraw [gray] (0, 0) rectangle (4.0, 0.3);
    \end{tikzpicture} & 1.000&353\\

\end{tabular}\\

Эффективней всего оказалось применить алгоритм RLE, который сократит 
повторяющиеся символы и затем алгоритм Шеннона-Фано или Хаффмана. \\

Полный исходный код эксперимента: \\
\href{https://github.com/IAmProgrammist/information_theory/blob/main/src/main/java/rchat/info/lab3/Main.java}{Main.java (https://github.com/IAmProgrammist/information\_theory/blob/main/src/main\\/java/rchat/info/lab3/Main.java)}\\
\href{https://github.com/IAmProgrammist/information_theory/blob/main/src/main/java/rchat/info/libs/Coder.java}{Coder.java (https://github.com/IAmProgrammist/information\_theory/blob/main/src/main\\/java/rchat/info/libs/Coder.java)}\\

Файлы эксперимента: \\
\href{https://github.com/IAmProgrammist/information_theory/tree/main/src/assets/lab3}{Ссылка (https://github.com/IAmProgrammist/information\_theory/tree/maiт\\/src/assets/lab3)}\\

\textbf{Выводы: } наименее эффективными оказались алгоритмы с двойным применением RLE, методы
повторного кодирования при помощи того же метода. Чаще всего они проигрывали или вызывали
переполнение кучи. Эффективней оказались алгоритмы с применением RLE до или после Шеннона-Фано
или Хаффмана в ситуациях с коротким алфавитом и множеством повторяющихся символов.
Такие методы будут полезны, например, при кодировании очень тёмных или очень светлых изображений, где очень часто 
встречаются повторяющиеся подряд пиксели.
Не всегда самыми эффективными, но всегда уменьшающими размер оказались алгоритмы 
Шеннона-Фано или Хаффмана без применения RLE. 
\end{document}