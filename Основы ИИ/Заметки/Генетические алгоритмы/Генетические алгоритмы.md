---
created: 2025-10-09T09:52:26.2626+00:00
modified: 2025-10-09T10:54:51.5151+00:00
---
За основу взят естественный отбор. В отличие от прочих алгоритмов оптимизации, не пытается оптимизировать единственное решение. Алгоритм работает с некоторой группой решений, которая кодируется подобно хромосомам. Отдельные *гены* хромосомы представляют собой уникальные переменные для изучаемой проблемы. 

![[Основы ИИ/Заметки/Изображения/Pasted image 20251009125800.png]]

Как видно из примера, за основу берутся параметры проблемы и создаётся хромосома, которая задаётся двумя независимыми параметрами. Параметрами могут могут быть булевые значения, числа с плавающей точкой. При отборе здоровых хромосом из популяции и использовании операторов, например рекомбинация и мутация, в популяции остаются только те хромосомы, которые лучше прочих приспособлены к окружающей среде. То есть, наиболее полно отвечают задаче. 

Выполнение генетического алгоритма включает три основных шага, и для каждого шага предусмотрен разброс вариантов
![[Основы ИИ/Заметки/Изображения/Pasted image 20251009125836.png]]

Архитектура алгоритма позволяет одну и ту же задачу решить различными способами. Существуют различные сценарии работы. Если не учитывать [[Основы ИИ/Заметки/Генетические алгоритмы/Этапы/Инициализация|начальное создание популяции]], можно сказать, что алгоритм содержит три этапа. В ходе оценки определяется здоровье популяции, потом производится отбор хромосом с учётом предварительно заданного критерия. Наконец, выбранная подгруппа рекомбинируется, в результате чего создаётся новая популяция. Алгоритм выполняется заново с новой популяцией. Такой процесс выполняется до тех пор, пока не будет достигнут определённый предел. Тогда работа алгоритма считается завершённой. 

В результате получаем новый набор хромосом. Повторяем снова и снова до тех пор, пока проблема не будет решена или будет выполнено любое другое условие завершения алгоритма. Например, достигнуто максимальное количество итераций. 

>[!info] Пример
>Максимизируем функцию $f(x,y) = \frac{1}{1 + x^2 + y^2}$. 
>![[Основы ИИ/Заметки/Изображения/Pasted image 20251009133753.png]]
>Хромосомы в этом примере были построены из двух генов. [[Основы ИИ/Заметки/Генетические алгоритмы/Этапы/Инициализация|Инициализируем]] фонд хромосом
>![[Основы ИИ/Заметки/Изображения/Pasted image 20251009133823.png]]
>[[Основы ИИ/Заметки/Генетические алгоритмы/Этапы/Оценка|Определим здоровье]] каждой хромосомы. Здесь здоровые будет равно значению функции.
>![[Основы ИИ/Заметки/Изображения/Pasted image 20251009133929.png]]
>Выполним [[Основы ИИ/Заметки/Генетические алгоритмы/Этапы/Отбор|отбор]] и определим две пары родителей для [[Основы ИИ/Заметки/Генетические алгоритмы/Этапы/Рекомбинация|рекомбинирования]]. 
>![[Основы ИИ/Заметки/Изображения/Pasted image 20251009134047.png]]
>В дальнейшем будем снова и снова повторять этот алгоритм. Лучшее решение в новой популяции эффективней, чем в первой, так как её здоровье выше. 

>[!info] Пример
>Вместо того, чтобы фокусироваться на операциях численных, решим проблему с последовательностью указаний. 
>![[Основы ИИ/Заметки/Изображения/Pasted image 20251009134657.png]]
>Компьютер имеет набор значений, которыми можно управлять инструкциями. Алгоритм распознаёт только определённый набор инструкций. Данные функции просты и могут использоваться во многих функциях. В данном случае хромосома отображает набор инструкций в одном блоке. Для каждой инструкции необходимо задать числовое значение. Кодировка - группа байтов, представляющих набор инструкций. Что касается оценки здоровья, оценка здоровья будет заключаться в выполнении последовательности инструкций хромосомы.. Создаётся стек, в него помещаются изначальные значения. А после этого последовательно выполняются все инструкции до тех пор, пока не программа не будет завершена или не будет достигнута инструкция $END$. Здоровье - разница между результатами вычислений и тем значением, которое ожидалось от функции. Для решения данной проблемы используется как [[Основы ИИ/Заметки/Генетические алгоритмы/Генетические операторы/Перекрёстное скрещивание|перекрёстное скрещивание]], так и [[Основы ИИ/Заметки/Генетические алгоритмы/Генетические операторы/Мутации|мутация]]. Причём перекрёстное скрещивание делает разрыв в одном месте. А мутация изменяет одну из инструкций на произвольную. 
 