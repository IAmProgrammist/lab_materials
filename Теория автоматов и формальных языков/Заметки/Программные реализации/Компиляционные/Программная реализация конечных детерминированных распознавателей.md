---
created: 2025-01-21T10:27:10.1010+00:00
modified: 2025-01-21T10:39:05.055+00:00
---
Рассмотрим компиляционный способ программной реализации [[Теория автоматов и формальных языков/Заметки/Конечные распознаватели/Конечный детерминированный распознаватель|конечных детерминированных распознавателей]]

В качестве примера будет использоваться следующий КДР

![[Теория автоматов и формальных языков/Заметки/Изображения/Pasted image 20250120115200.png]]

# Алгоритм 1 (рекурсионный)
Код каждого состояния отметим соответствующей меткой. Переменную x будем использовать для хранения символа входной цепочки. Анализ переменной х выполним с помощью оператора множественного выбора. Переход в новое состояние закодируем оператором безусловного перехода на метку. Концевой маркер обозначим символом ‘┤’
```
s0: 
	ввод (х); 
	выбор (х)
		х in {‘+’,’-‘} : переход на s1; 
		х in {‘0’..’9‘} : переход на s2; 
		х = '.' : переход на s3; 
		x = ‘┤’ : вывод ( ‘Отвергнуть, цепочка пуста’), конец. 
	конец выбор; 


s1: 
	ввод (х); 
	выбор (х) 
		х in {‘0’..’9‘} : переход на s2; 
		х = '.' : переход на s3; 
		х in {‘+’,’-‘} : вывод ( ‘Отвергнуть, недопустимы два знака подряд’), конец. 
		x = ‘┤’ : вывод ( ‘Отвергнуть, нет значения константы’), конец. 
	конец выбор; 


s2: 
	ввод (х); 
	выбор (х) 
		х in {‘0’..’9‘} : переход на s2; 
		х = '.' : переход на s4; 
		иначе : вывод ( ‘Отвергнуть, в вещественной константе должна быть точка ’), конец. 
	конец выбор; 


s3: 
	ввод (х); 
	выбор (х) 
		х in {‘0’..’9‘} : переход на s4; 
		иначе : вывод ( ‘Отвергнуть, после точки должна быть цифра’), конец. 
	конец выбор; 


s4: 
	ввод (х); 
	выбор (х) 
		х in {‘0’..’9‘} : переход на s4; 
		х in {‘+’,’-‘,'.'} : вывод ( ‘Отвергнуть, последний символ не может встречаться дважды’), конец. 
		x = ‘┤’ : вывод ( ‘Допустить’), конец. 
	конец выбор;
```

# Алгоритм 2 (итерационный)
Номер текущего состояния будем хранить в переменной S , а для его определения будем использовать множественный выбор, каждая альтернатива которого соответствует состоянию. Символ входной цепочки будем хранить в переменной x , а для его анализа будем использовать множественный выбор. Переходу в новое состояние соответствует присваивание переменной S нового значения. Распознавание будем выполнять в цикле, пока не будет введён концевой маркер или пока в S не записано состояние ошибки. Состояние ошибки представим отрицательным числом, которое так же является кодом ошибки. После выхода из цикла выводится результат – ‘допустить’ или ‘отвергнуть’ и, если ‘отвергнуть’, то выводится сообщение об ошибке.

```
S := 0; 
повторять 
	ввод (х); 
	выбор (S) 
		S = 0 : 
			выбор (х) 
				х in {‘+’,’-‘} : S := 1; 
				х in {‘0’..’9‘} : S := 2; 
				х = '.' : S := 3; 
				x = ‘┤’ : S := -1; 
			конец выбор; 
		
		S = 1 : 
			выбор (х) 
				х in {‘0’..’9‘} : S = 2; 
				х = '.' : S = 3; 
				х in {‘+’,’-‘} : S := -2; 
				x = ‘┤’ : S = -3; 
			конец выбор; 
		
		S = 2 : 
			выбор (х) 
				х in {‘0’..’9‘} : S = 2; 
				х = '.' : S = 4; 
				иначе : S = -4; 
			конец выбор; 
		
		S = 3 : 
			выбор (х) 
				х in {‘0’..’9‘} : S = 4; 
				х = '.' : S = 4; 
				иначе : S = -5; 
			конец выбор; 
		
		S = 4 : 
			выбор (х) 
				х in {‘0’..’9‘} : S = 4; 
				х in {‘+’,’-‘,'.'} : S = -6; 
			конец выбор; 
		
	конец выбор; 
пока S >= 0 и х != ‘┤’ ; 

выбор (S) 
	S = 4 : вывод ( ‘Допустить’); 
	S = -1 : вывод ( ‘Отвергнуть, цепочка пуста’); 
	S = -2 : вывод ( ‘Отвергнуть, недопустимы два знака подряд’); 
	S = -3 : вывод ( ‘Отвергнуть, нет значения константы’); 
	S = -4 : вывод ( ‘Отвергнуть, в вещественной константе должна быть точка ’); 
	S = -5 : вывод ( ‘Отвергнуть, после точки должна быть цифра’); 
	S = -6 : вывод ( ‘Отвергнуть, последний символ не может встречаться дважды’);
конец выбор;
```