---
created: 2025-01-21T10:38:54.5454+00:00
modified: 2025-01-21T10:41:19.1919+00:00
---
Рассмотрим интерпретационный способ программной реализации [[Теория автоматов и формальных языков/Заметки/Конечные распознаватели/Конечный детерминированный распознаватель|конечных детерминированных распознавателей]]

В качестве примера будет использоваться следующий КДР

![[Теория автоматов и формальных языков/Заметки/Изображения/Pasted image 20250120115200.png]]

В этом способе реализации используется табличный способ задания конечного детерминированного распознавателя. Таблица распознавателя сохраняется в памяти и обрабатывается по определённому, общему для всех распознавателей, алгоритму. Номер состояния распознавателя будем хранить в переменной S , символ входной цепочки - в переменной x . На каждом шаге распознавания, пока не введён концевой маркер, определяется состояние перехода путём обращения к элементу таблицы распознавателя, расположенному в строке, соответствующей входному символу х , и столбце, соответствующем состоянию S . С помощью функции L(x) поставим в соответствие каждому входному символу номер строки таблицы. Для быстрого вычисления L(x) представим эту функцию в табличной форме и сохраним в массиве L таким образом, что элемент L[x] содержит номер строки таблицы распознавателя, соответствующей входному символу х . В результате, для вычисления значения функции L(x) достаточно обратиться к элементу L[x] . Переходы в состояние ошибки закодируем отрицательными числами, представляющими собой код ошибки. Сообщения об ошибках будем хранить в таблице ошибок. Выход из процесса распознавания происходит при вводе концевого маркера или достижении состояния ошибки. 

Итак, для реализации конечного детерминированного распознавателя интерпретационным способом, необходимо иметь:
1. таблицу переходов конечного детерминированного распознавателя; 
2. множество допускающих состояний; 
3. массив L для определения строки, таблицы, соответствующей входному символу; 
4. таблицу ошибок.

```
S := 0; 
повторять 
	ввод (х); 
	S := таблица_переходов[L[x],S]; 
пока S >= 0 и х != ‘┤’; 

если S in множество_допускающих_сотояний то 
	вывод (‘Допустить’) 
иначе 
	вывод(‘Отвергнуть ’, таблица_ошибок[|S|]);
```