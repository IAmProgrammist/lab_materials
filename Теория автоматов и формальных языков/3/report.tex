\documentclass[a4paper,14pt]{extarticle}


\usepackage[english,russian]{babel}
\usepackage[T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{ragged2e}
\usepackage[utf8]{inputenc}
\usepackage{hyperref}
\usepackage{minted}
\setmintedinline{frame=lines, framesep=2mm, baselinestretch=1.5, bgcolor=LightGray, breaklines,fontsize=\scriptsize}
\setminted{frame=lines, framesep=2mm, baselinestretch=1.5, bgcolor=LightGray, breaklines,fontsize=\scriptsize}
\usepackage{xcolor}
\definecolor{LightGray}{gray}{0.9}
\usepackage{graphicx}
\usepackage[export]{adjustbox}
\usepackage[left=1cm,right=1cm, top=1cm,bottom=1cm,bindingoffset=0cm]{geometry}
\usepackage{fontspec}
\usepackage{ upgreek }
\usepackage[shortlabels]{enumitem}
\usepackage{adjustbox}
\usepackage{multirow}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{pifont}
\usepackage{pgfplots}
\usepackage{longtable}
\usepackage{array}
\graphicspath{ {./images/} }
\makeatletter
\AddEnumerateCounter{\asbuk}{\russian@alph}{щ}
\makeatother
\setmonofont{Ubuntu Mono}
\setmainfont{Times New Roman}

\newcommand\textbox[1]{
	\parbox{.45\textwidth}{#1}
} 

\newcommand{\specialcell}[2][c]{%
	\begin{tabular}[#1]{@{}c@{}}#2\end{tabular}}

\begin{document}
\pagenumbering{gobble}
\begin{center}
    \small{
        \textbf{МИНИCТЕРCТВО НАУКИ И ВЫCШЕГО ОБРАЗОВАНИЯ РОCCИЙCКОЙ ФЕДЕРАЦИИ}\\
        ФЕДЕРАЛЬНОЕ ГОCУДАРCТВЕННОЕ БЮДЖЕТНОЕ ОБРАЗОВАТЕЛЬНОЕ УЧРЕЖДЕНИЕ\\ВЫCШЕГО ОБРАЗОВАНИЯ \\
        \textbf{«БЕЛГОРОДCКИЙ ГОCУДАРCТВЕННЫЙ ТЕХНОЛОГИЧЕCКИЙ\\УНИВЕРCИТЕТ им. В. Г. ШУХОВА»\\ (БГТУ им. В.Г. Шухова)} \\
        \bigbreak
        \includegraphics[width=70mm]{log}\\
        ИНСТИТУТ ИНФОРМАЦИОННЫХ ТЕХНОЛОГИЙ И УПРАВЛЯЮЩИХ СИСТЕМ\\}
\end{center}

\vfill
\begin{center}
    \large{
        \textbf{
            Лабораторная работа №3}}\\
    \normalsize{
        по дисциплине: Теория автоматов и формальных языков \\
        тема: «Регулярные языки и конечные распознаватели»}
\end{center}
\vfill
\hfill\textbox{
    Выполнил: ст. группы ПВ-223\\Пахомов Владислав Андреевич
    \bigbreak
    Проверили: \\ст. пр. Рязанов Юрий Дмитриевич
}
\vfill\begin{center}
    Белгород 2024 г.
\end{center}
\newpage
\begin{center}
    \textbf{Лабораторная работа №3}\\
    Регулярные языки и конечные распознаватели\\
    Вариант 8
\end{center}
\textbf{Цель работы: }изучить основные способы задания регулярных языков, 
способы построения, алгоритмы преобразования, анализа и реализации конечных 
распознавателей.\\

\begin{enumerate}[1.]
    \item Язык $L_1$ в алфавите $\{0,1\}$, представляющий собой множество цепочек, в которых на предпослежнем месте стоит единица, задан грамматикой:\\
    S → A10\\
    A → A011\\
    A → 0A\\
    A → 1A\\
    A → ε\\
    Построить детерминированный конечный распознаватель языка $L_1$.\bigbreak
    Преобразуем заданную грамматику к автоматной правосторонней. Сейчас она является КС-грамматикой.\\
    Приведём грамматику и устраним левую рекурсию.\\
    Лишних символов в грамматике нет.\\
    В грамматике есть ε-правило. Исключим его.\\
    S → A10\\
    S → 10\\
    A → A011\\
    A → 011\\
    A → 0A\\
    A → 0\\
    A → 1A\\
    A → 1\\
    Цепных правил в грамматике нет.\\
    В грамматике есть левая рекурсия. Исключим её.\\
    S → A10\\
    S → 10\\
    A → 011B\\
    A → 0AB\\
    A → 0B\\
    A → 1AB\\
    A → 1B\\
    A → 011\\
    A → 0A\\
    A → 0\\
    A → 1A\\
    A → 1\\
    B → 011B\\
    B → ε\\
    В грамматике есть ε-правило. Исключим его.\\
    S → A10\\
    S → 10\\
    A → 011\\
    A → 011B\\
    A → 0A\\
    A → 0AB\\
    A → 0\\
    A → 0B\\
    A → 1A\\
    A → 1AB\\
    A → 1\\
    A → 1B\\
    A → 011\\
    A → 0A\\
    A → 0\\
    A → 1A\\
    A → 1\\
    B → 011B\\
    B → 011\\
    Исключим правила-дубликаты:\\
    S → A10\\
    S → 10\\
    A → 011\\
    A → 011B\\
    A → 0A\\
    A → 0AB\\
    A → 0\\
    A → 0B\\
    A → 1A\\
    A → 1AB\\
    A → 1\\
    A → 1B\\
    B → 011B\\
    B → 011\\
    Грамматика приведена, а также в ней нет левой рекурсии. 
    Преобразуем грамматику к такому виду, что каждое 
    правило будет начинаться с терминала:\\ 

    S → 01110\\
    S → 011B10\\
    S → 0A10\\
    S → 0AB10\\
    S → 010\\
    S → 0B10\\
    S → 1A10\\
    S → 1AB10\\
    S → 110\\
    S → 1B10\\
    S → 10\\
    A → 011\\
    A → 011B\\
    A → 0A\\
    A → 0AB\\
    A → 0\\
    A → 0B\\
    A → 1A\\
    A → 1AB\\
    A → 1\\
    A → 1B\\
    B → 011B\\
    B → 011\\

    Преобразуем КС-грамматику к правосторонней:\\
    \includegraphics[width=140mm]{task1fail}\\
    Преобразовать грамматику к правосторонней невозможно, так как 
    в ходе преобразований получили правило (подчёркнутое с !!! в вычислениях) $N_4$ → AB$N_1$. 
    С правилом $N_3$ → A$N_1$ они имеют общий префикс и постфикс, в дальнейшем мы будем получать правила вида 
    AB*$N_1$, получаем рекурсию, и следовательно правостороннюю грамматику с конечным числом правил получить нельзя. 
    Задание невыполнимо.
\item Язык $L_2$ в алфавите $\{0,1\}$, представляющий собой множество цепочек, в
которых на последнем месте стоит единица, задан регулярным выражением:\\
(0+1)*1\\
Построить детерминированный конечный распознаватель языка $L_2$.\\
Для начала построим конечный недетерминированный распознаватель языка:\\
\includegraphics[width=70mm]{task2_non_determined}\\
Данный распознаватель языка не является детерминированным, 
так как он содержит ε-переходы. 
Преобразуем данный конечный распознаватель языка в детерминированный:\\
\begin{tabular}{|c|c|c|c|c|c|}
	\hline
	   & $\downarrow$ &    &    & 1  \\
	\hline
	   & S1           & S2 & S3 & S4 \\
	\hline
	1  &              & S2 & S4 &    \\
	\hline
	0  &              & S2 &    &    \\
	\hline
	ε  & S2           & S3 &    &    \\
	\hline
\end{tabular}

Удалим ε-переходы:\\ 
ε-замыкания: ε(S1) = \{S1, S2\}, ε(S2) = \{S2, S3\}, ε(S3) = \{S3\}, ε(S4) = \{S4\}\\
\begin{tabular}{|c|c|c|c|c|}
    \hline
    & $\downarrow$ & $\downarrow$ & & 1\\
    \hline
    & \begin{tabular}{c}ε(S1)\\\{S1, S2\}\end{tabular} & \begin{tabular}{c}ε(S2)\\\{S2, S3\}\end{tabular} & \begin{tabular}{c}ε(S3)\\\{S3\}\end{tabular} & \begin{tabular}{c}ε(S4)\\\{S4\}\end{tabular} \\
    \hline
    1 & ε(S2) & ε(S2), ε(S4) & ε(S4) & \\
    \hline
    0 & ε(S2) & ε(S2) & & \\
    \hline
\end{tabular} 

\begin{tabular}{|c|c|c|c|c|}
    \hline
    & $\downarrow$ & $\downarrow$ & & 1\\
    \hline
    & S1 & S2 & S3 & S4 \\
    \hline
    1 & S2, S3 & S2, S3, S4 & S4 & \\
    \hline
    0 & S2, S3 & S2, S3 & & \\
    \hline
\end{tabular} 

\includegraphics[width=70mm]{task2_no_e_routes}\\

Преобразуем недетерминированный конечный распознаватель в детерминированный:\\
\begin{tabular}{|c|c|c|c|}
    \hline
    & & &\\
    \hline
    & \{S1, S2\} & \{S2, S3\} & \{S2, S3, S4\}\\
    \hline
    1 & \{S2, S3, S4\} & \{S2, S3, S4\} & \{S2, S3, S4\}\\
    \hline
    0 & \{S2, S3\} & \{S2, S3\} & \{S2, S3\}\\
    \hline
\end{tabular} 

Обозначим множества состояний как S'1, S'2, S'3...\\
S'1 обозначим как начальное состояние, солгасно алгоритму, а 
S'3 обозначим как допускающее состояние, так как множество $\{S2, S3, S4\}$
включает в себя допускающее состояние S4.

\begin{tabular}{|c|c|c|c|}
    \hline
    & $\downarrow$ & & 1\\
    \hline
    & S'1 & S'2 & S'3\\
    \hline
    1 & S'3 & S'3 & S'3\\
    \hline
    0 & S'2 & S'2 & S'2\\
    \hline
\end{tabular} 

\includegraphics[width=70mm]{task2_determined}\\

Построили детерминированный конечный распознаватель языка $L_2$.
\item Построить минимальный детерминированный конечный распознаватель
языка $L_3$ в алфавите \{0,1\}, представляющий собой множество цепочек, в
которых хотя бы на одной из последних двух позиций стоит единица.

Пусть у нас будет исходный распознаватель языка $L_3$. В начальном состоянии S1 мы итеративно 
получаем 0 и 1, для окончания работы переходим в состояние S2 под действием символа
1, из него можем попасть в допускающие состояния S3 или S4 под действием символов 0 и 1 соответственно, 
так как если 1 - предпоследний символ, то строку можем закончить либо 1 либо 0. 
Если же предпоследний символ - 0, то из состояния S1 можно перейти в состояние S5 
под действием символа 0. Однако из S5 мы теперь можем попасть только в S3, так как если предпоследний 
символ - 0, то последним обязательно должен быть 1. Получили недетерминированный конечный алгоритм
без ε-переходов:\\
\begin{tabular}{|c|c|c|c|c|c|}
    \hline
    & $\downarrow$ & & 1 & 1 & \\
    \hline
    & S1 & S2 & S3 & S4 & S5 \\
    \hline
    1 & S1, S2 & S4 & & & S4 \\
    \hline
    0 & S1, S5 & S3 & & & \\
    \hline
\end{tabular}
\includegraphics[width=70mm]{task3_non_determined}\\

Преобразуем распознаватель в детерминированный:\\
\begin{tabular}{|c|c|c|c|c|c|}
    \hline
    & & & & &\\
    \hline
    & \{S1\} & \{S1, S2\} & \{S1, S5\} & \{S1, S2, S4\} & \{S1, S5, S3\}\\
    \hline
    1 & \{S1, S2\} & \{S1, S2, S4\} & \{S1, S2, S4\} & \{S1, S2, S4\} & \{S1, S2, S4\}\\
    \hline
    0 & \{S1, S5\} & \{S1, S5, S3\} & \{S1, S5\} & \{S1, S5, S3\} & \{S1, S5\}\\
    \hline
\end{tabular} 

\begin{tabular}{|c|c|c|c|c|c|}
    \hline
    & $\downarrow$ & & & 1 & 1 \\
    \hline
    & S1 & S2 & S3 & S4 & S5 \\
    \hline
    1 & S2 & S4 & S4 & S4 & S4 \\
    \hline
    0 & S3 & S5  & S3 & S5 & S3 \\
    \hline
\end{tabular}
\includegraphics[width=70mm]{task3_determined}\\

Полученный распознаватель является детерминированным, однако является ли он 
минимальным?\\
В распознавателе нет состояний, недостижимых из начального.\\
Перейдём к поиску и исключению эквивалентных состояний:\\
\begin{tabular}{|c|c|c|c|c|c|c|}
    \hline
    & $\downarrow$ & & & 1 & 1 &\\
    \hline
    & S1 & S2 & S3 & S4 & S5 &\\
    \hline
    1 & S2 & S4 & S4 & S4 & S4& \\
    \hline
    0 & S3 & S5  & S3 & S5 & S3& \\
    \hline
\end{tabular}

Отвергающие состояния \{S1, S2, S3\} объединим в класс K1 0-эквивалентных состояний, 
а допускающие состояния \{S4, S5\} - в класс K2.

\begin{tabular}{|c|c|c|c|c|c|c|}
    \hline
    & \multicolumn{4}{c|}{K1} & \multicolumn{2}{c|}{K2} \\
    \hline
    & S1 & S2 & S3&    & S4 & S5 \\
    \hline
    1 & K1 & K2 & K2 & K1 & K2 & K2 \\
    \hline
    0 & K1 & K2  & K1 & K1 & K2 & K1 \\
    \hline
\end{tabular}

Получили таблицу переходов в классы 0-эквивалентных состояний. На основе 
этой таблицы можем построить таблицу переходов в классы 1-эквивалентных 
состояний. 

\begin{tabular}{|c|c|c|c|c|c|c|}
    \hline
    & \multicolumn{2}{c|}{K1} & K2 & K3 & K4 & K5 \\
    \hline
      & S1 &    & S3 & S2 & S4 & S5 \\
    \hline
    1 & K3 & K1 & K4 & K4 & K4 & K4 \\
    \hline
    0 & K2 & K1 & K2 & K5 & K5 & K2 \\
    \hline
\end{tabular}

Получили таблицу переходов в классы 1-эквивалентных состояний. На основе 
этой таблицы можем построить таблицу переходов в классы 2-эквивалентных 
состояний. 

\begin{tabular}{|c|c|c|c|c|c|c|}
    \hline
      & K1 & K2 & K3 & K4 & K5 & K6 \\
    \hline
      & S1 &    & S3 & S2 & S4 & S5 \\
    \hline
    1 & K4 & K2 & K5 & K5 & K5 & K5 \\
    \hline
    0 & K3 & K2 & K3 & K6 & K6 & K3 \\
    \hline
\end{tabular}

Ни в одном из получившихся классов эквивалентных состояний не получилось
более одного столбца, значит распознаватель является минимальным. 

Построили минимальный детерминированный конечный распознаватель языка $L_3$.

\item Написать программу компиляционного типа для реализации
минимального детерминированного конечного распознавателя языка $L_3$.

\begin{minted}{python3}
MESSAGES = {
    -1: "Отвергнуть, последовательность пуста",
    -2: "Отвергнуть, невалидный входной символ",
    -3: "Отвергнуть, слишком короткая цепочка",
    -4: "Отвергнуть, последние два символа не содержат 1",
    0: "Допустить"
}

def S1(input):
    if len(input) == 0:
        return -1

    if input[0] == '1':
        return S2(input[1:])
    elif input[0] == '0':
        return S3(input[1:])
    else:
        return -2

def S2(input):
    if len(input) == 0:
        return -3

    if input[0] == '1':
        return S4(input[1:])
    elif input[0] == '0':
        return S5(input[1:])
    else:
        return -2

def S3(input):
    if len(input) == 0:
        return -4

    if input[0] == '1':
        return S4(input[1:])
    elif input[0] == '0':
        return S3(input[1:])
    else:
        return -2


def S4(input):
    if len(input) == 0:
        return 0

    if input[0] == '1':
        return S4(input[1:])
    elif input[0] == '0':
        return S5(input[1:])
    else:
        return -2


def S5(input):
    if len(input) == 0:
        return 0

    if input[0] == '1':
        return S4(input[1:])
    elif input[0] == '0':
        return S3(input[1:])
    else:
        return -2

def L3validator(input):
    result = S1(input)
    print(input, MESSAGES[result])
    return result
\end{minted}

\item Написать программу интерпретационного типа для реализации
минимального детерминированного конечного распознавателя языка $L_3$.

\begin{minted}{python3}
MESSAGES = {
    0: "Отвергнуть, последовательность пуста",             # -1
    3: "Отвергнуть, невалидный входной символ",            # -2
    1: "Отвергнуть, слишком короткая цепочка",             # -3
    2: "Отвергнуть, последние два символа не содержат 1",  # -4
    4: "Допустить",                                       # 0
}

PERMITTING = [3, 4]

MATRIX = {
    "1": [1, 3, 3, 3, 3],
    "0": [2, 4, 2, 4, 2]
}

def L3validator(input):
    input_origin = input
    S = 0
    while len(input) > 0 and S >= 0:
        S = MATRIX[input[0]][S]
        input = input[1:]

    if S in PERMITTING:
        S = 4

    print(input_origin, MESSAGES[S])
    return S
\end{minted}

\item Подобрать наборы тестовых данных так, чтобы в процессе тестирования
сработал каждый переход конечного распознавателя.

\begin{enumerate}
    \item 10001101 - уникальные тестируемые переходы отмечены красным
    \item 11 - уникальные тестируемые переходы отмечены зелёным
    \item 01 - уникальные тестируемые переходы отмечены голубым
\end{enumerate}

\includegraphics[width=70mm]{task6}\\

Тесты для компиляционного варианта программы:\\
\begin{minted}{python3}
# Тестовые данные для всех переходов
assert L3validator("10001101") == 0
assert L3validator("11") == 0
assert L3validator("01") == 0
\end{minted}

Тесты для интерпретационного варианта программы:\\
\begin{minted}{python3}
# Тестовые данные для всех переходов
assert L3validator("10001101") == 4
assert L3validator("11") == 4
assert L3validator("01") == 4
\end{minted}

\item Подобрать наборы тестовых данных так, чтобы в процессе тестирования
распознаватель закончил обработку цепочек в каждом состоянии конечного
распознавателя.

\begin{enumerate}
    \item <пустая строка> - состояние S1
    \item 1 - состояние S2
    \item 0 - состояние S3
    \item 11 - состояние S4
    \item 10 - состояние S5
\end{enumerate}

Тесты для компиляционного варианта программы:\\
\begin{minted}{python3}
# Тестовые данные для всех состояний
assert L3validator("") == -1
assert L3validator("1") == -3
assert L3validator("0") == -4
assert L3validator("11") == 0
assert L3validator("10") == 0
\end{minted}

Тесты для интерпретационного варианта программы:\\
\begin{minted}{python3}
# Тестовые данные для всех состояний
assert L3validator("") == 0
assert L3validator("1") == 1
assert L3validator("0") == 2
assert L3validator("11") == 4
assert L3validator("10") == 4
\end{minted}

\item Выполнить тестирование программ для реализации минимального
детерминированного конечного распознавателя языка $L_3$.\\

Результаты выполнения компиляционного варианта программы:\\
\begin{minted}{console}
10001101 Допустить
11 Допустить
01 Допустить
 Отвергнуть, последовательность пуста
1 Отвергнуть, слишком короткая цепочка
0 Отвергнуть, последние два символа не содержат 1
11 Допустить
10 Допустить

Process finished with exit code 0
\end{minted}

Результаты выполнения интерпретационного варианта программы:\\
\begin{minted}{console}
10001101 Допустить
11 Допустить
01 Допустить
 Отвергнуть, последовательность пуста
1 Отвергнуть, слишком короткая цепочка
0 Отвергнуть, последние два символа не содержат 1
11 Допустить
10 Допустить

Process finished with exit code 0
\end{minted}

Оба варианта программы завершились без ошибок, а значит проверки 
в проверках истинные, следовательно программа написана верно.

\end{enumerate}

\textbf{Вывод: } в ходе лабораторной работы изучили основные способы задания регулярных языков, 
способы построения, алгоритмы преобразования, анализа и реализации конечных 
распознавателей.

\end{document}