\documentclass[a4paper,14pt]{extarticle}


\usepackage[utf8]{inputenc}
\usepackage[T2A]{fontenc}
\usepackage[english,russian]{babel}
\usepackage{ragged2e}
\usepackage[utf8]{inputenc}
\usepackage{hyperref}
\usepackage{minted}
\setmintedinline{frame=lines, framesep=2mm, baselinestretch=1.5, bgcolor=LightGray, breaklines,fontsize=\scriptsize}
\setminted{frame=lines, framesep=2mm, baselinestretch=1.5, bgcolor=LightGray, breaklines,fontsize=\scriptsize}
\usepackage{xcolor}
\definecolor{LightGray}{gray}{0.9}
\usepackage{graphicx}
\usepackage[export]{adjustbox}
\usepackage[left=1cm,right=1cm, top=1cm,bottom=1cm,bindingoffset=0cm]{geometry}
\usepackage{fontspec}
\usepackage{ upgreek }
\usepackage[shortlabels]{enumitem}
\usepackage{adjustbox}
\usepackage{multirow}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{pifont}
\usepackage{pgfplots}
\usepackage{longtable}
\usepackage{array}
\graphicspath{ {./images/} }
\makeatletter
\AddEnumerateCounter{\asbuk}{\russian@alph}{щ}
\makeatother
\setmonofont{Ubuntu Mono}
\setmainfont{Times New Roman}

\newcommand\textbox[1]{
	\parbox{.45\textwidth}{#1}
} 

\newcommand{\specialcell}[2][c]{%
	\begin{tabular}[#1]{@{}c@{}}#2\end{tabular}}

\begin{document}
\pagenumbering{gobble}
\begin{center}
    \small{
        \textbf{МИНИCТЕРCТВО НАУКИ И ВЫCШЕГО ОБРАЗОВАНИЯ РОCCИЙCКОЙ ФЕДЕРАЦИИ}\\
        ФЕДЕРАЛЬНОЕ ГОCУДАРCТВЕННОЕ БЮДЖЕТНОЕ ОБРАЗОВАТЕЛЬНОЕ УЧРЕЖДЕНИЕ\\ВЫCШЕГО ОБРАЗОВАНИЯ \\
        \textbf{«БЕЛГОРОДCКИЙ ГОCУДАРCТВЕННЫЙ ТЕХНОЛОГИЧЕCКИЙ\\УНИВЕРCИТЕТ им. В. Г. ШУХОВА»\\ (БГТУ им. В.Г. Шухова)} \\
        \bigbreak
        \includegraphics[width=70mm]{log}\\
        ИНСТИТУТ ИНФОРМАЦИОННЫХ ТЕХНОЛОГИЙ И УПРАВЛЯЮЩИХ СИСТЕМ\\}
\end{center}

\vfill
\begin{center}
    \large{
        \textbf{
            Лабораторная работа №4}}\\
    \normalsize{
        по дисциплине: Параллельное программирование \\
        тема: «Параллельное программирование с использованием OpenCL»}
\end{center}
\vfill
\hfill\textbox{
    Выполнил: ст. группы ПВ-223\\Пахомов Владислав Андреевич
    \bigbreak
    Проверили: \\доц. Островский Алексей Мичеславович
}
\vfill\begin{center}
    Белгород 2025 г.
\end{center}
\newpage
\underline{\textbf{Цель работы: }}Изучить основы параллельного программирования с использованием OpenCL,
реализовать вычислительные задачи с применением графического ускорителя (GPU), оценить
производительность и масштабируемость решений при выполнении вычислений.\\
\underline{\textbf{Условие индивидуального задания: }}\\
Реализовать параллельные алгоритмы для обучения и предсказания с помощью
логистической регрессии. Дан набор данных dataset[N][D], где N — количество обучающих
примеров, D — размерность признакового пространства (загрузка из файла). Даны метки
labels[N] (выходные значения 0 или 1). Модель: логистическая регрессия с функцией
активации sigmoid. Предсказание вычисляется по формуле:\\

$y_{pred} = sigmoid(\sum_{i=1}^{D}w_ix_i + b)$\\

где $w_i$ — веса модели, b — смещение. Требуется: реализовать параллельный прямой проход
(forward pass), где каждая параллельная нить (thread) вычисляет предсказание $y_{pred}$ для
одного обучающего примера. Реализовать параллельное вычисление локальных градиентов
по каждому примеру. Выполнить редукцию локальных градиентов для обновления весов и
смещения. Обеспечить эффективную работу на GPU с использованием OpenCL. После
обучения вывести предсказания на обучающем наборе данных и на новом тестовом примере.
Сравнить производительность (по времени выполнения) между реализациями на GPU и CPU.
Все данные использовать в формате float. Загрузка данных из файла.
\begin{center}
\textbf{Ход выполнения работы}
\end{center}

\textbf{Описание архитектурных решений}
Шейдер для вычисления предсказаний использует разбиения по группам для просчёта
предсказания для одного объекта. Размер группы представляет собой количество свойств объекта
наиболее близкое к $2^N$ (в большую сторону). В конце используется редукция сумма для 
получения итогового предсказания. Шейдер может работать как со множествами объектами, 
так и с одним объектом.

Шейдер для перерасчёта смещения и весов использует несколько другую композицию. В нём
в группе объединяется один признак объекта, а local\_id представляет собой номер объекта.
Соответственно размер группы будет количеством объектов наиболее близкое к $2^N$ (в большую)
сторону. В конце производится редукция градиентов и производится перерасчёт весов. А также
производится редукция для смещения и производится его перерасчёт.

Для пересчёта градиентов использовался другой подход, более подходящий под задачу параллелизации. (Asynchronous SGD)
Так, в примере градиент пересчитывался каждый раз с новыми данными и веса обновлялись на лету. 
При новом подходе градиенты считаются для всех предсказаний сразу и редуцируются. Такой подход может 
привести к потенциально худшим результатам, однако позволяет распараллелить задачу.

\textbf{Графики ускорения и зависимостей.}
Ниже приведено время выполнения программы при разных количествах эпох и свойств:\\
\begin{center}
    \includegraphics[width=140mm]{exp}\\
    \includegraphics[width=140mm]{exp_40}\\
    \includegraphics[width=140mm]{exp_80}\\
    \includegraphics[width=140mm]{exp_160}\\
    \includegraphics[width=140mm]{exp_diff_props}\\
\end{center}


\textbf{Вывод: } в ходе лабораторной работы изучили основы параллельного программирования с использованием OpenCL,
реализовать вычислительные задачи с применением графического ускорителя (GPU), оценить
производительность и масштабируемость решений при выполнении вычислений.

В данной задаче победить реализации на OpenCL процессор не удалось, однако
можно заметить, что время работы при выполнении на OpenCL при увеличении
количества свойств практически не растёт по сравнению с однопоточной реализацией.
Можно сделать вывод, что реализация OpenCL имеет смысл, если будут использоваться
многомерные данные, при маломерных данных с небольшим количеством нейронов, 
можно использовать и однопоточный подход.

Также для обучения нейронных моделей можно использовать специализированные
устройства, которые сегодня разрабатываются компанией Nvidia в частности. 
Эти устройства могут отличаться повышенным количеством ядер, памяти, 
возможности использования более широких групп с увеличенной локальной памятью.

Не стоит на месте и развитие стандартов. OpenCL, пусть и является одним из
широкоподдерживаемых стандартов, на сегодняшний день находится в стадии "угасания". 
Рекомендуется использовать более современные поддерживаемые технологии, такие как OpenGL, Vulkan. 
Производители устройств предлагают специализированные решения для конкретных устройств, 
так для AMD существует ROCm, для Nvidia существует CUDA. Однако возникает проблема 
совместимости, но есть решение и для неё. Так AMD HIP предлагает компиляцию как для 
CUDA, так и для ROCm (C++). Можно использовать Rust - более безопасный язык программирования -
для написания шейдеров, это возможно благодаря компиляции Rust в промежуточный шейдерный код SPIR-V, 
поддерживаемый многими технологиями при помощи пакета rust-gpu. Пакет всё ещё развивается, 
так в нём пока что ещё не поддерживается компиляция в OpenCL, поэтому данная лабораторная
работа и была выполнена с применением традиционного шейдера.

Современные тенденции развития графических ускорителей направлены на создание
универсального языка для написания программ для графических ускорителей а 
также на увеличения производительности для решения актуальных задач: использование
нейронных сетей а также их обучение. 

\end{document}